# -*- coding: utf-8 -*-
"""
Created on Tue Aug  5 08:35:31 2025
@author: zegar
"""

import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

from sklearn.impute import SimpleImputer
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import r2_score, mean_squared_error, classification_report, confusion_matrix
from sklearn.preprocessing import StandardScaler

# 1. Configuraci√≥n inicial
st.set_page_config(page_title="An√°lisis Estad√≠stico", layout="centered")
st.title("üìä An√°lisis de Satisfacci√≥n de Vida")

# 2. Carga de datos
@st.cache_data
def cargar_datos():
    return pd.read_csv("dataset_estadistica.csv")

try:
    dataset = cargar_datos()

    st.subheader("üìä Informaci√≥n Original del Dataset")
    st.write(dataset.head())

    # 3. Limpieza de datos
    dataset = dataset.drop_duplicates()

    numeric_cols = ['Edad', 'Ingreso_Mensual', 'Horas_Estudio_Semanal']
    categorical_cols = ['Nivel_Educativo', 'Genero']

    numeric_imputer = SimpleImputer(strategy="mean")
    dataset[numeric_cols] = numeric_imputer.fit_transform(dataset[numeric_cols])

    categorical_imputer = SimpleImputer(strategy="most_frequent")
    dataset[categorical_cols] = categorical_imputer.fit_transform(dataset[categorical_cols])

    st.subheader("‚úÖ Datos Limpios")
    st.write(dataset.head())
    
    st.download_button(
    label="üì• Descargar base limpia (sin codificar)",
    data=dataset.to_csv(index=False),
    file_name="dataset_limpio.csv",
    mime="text/csv"
)

    # 4. Estad√≠stica descriptiva
    st.subheader("üìà Estad√≠stica Descriptiva")
    st.write("**Resumen:**")
    st.write(dataset.describe())

    st.write("**Media**")
    st.write(dataset.mean(numeric_only=True))

    st.write("**Mediana**")
    st.write(dataset.median(numeric_only=True))

    st.write("**Moda**")
    st.write(dataset.mode(numeric_only=True))

    st.write("**Asimetr√≠a (Skewness)**")
    st.write(dataset.skew(numeric_only=True))

    st.write("**Curtosis (Kurtosis)**")
    st.write(dataset.kurtosis(numeric_only=True))

    #5. VISUALIZACI√ìN DE DISTRIBUCIONES Y RELACIONES
    st.subheader("üìä Visualizaci√≥n de Distribuciones y Relaciones")

    # üéÇ Distribuci√≥n de G√©nero
    st.markdown("### üéÇ Distribuci√≥n de G√©nero")
    gender_counts = dataset['Genero'].value_counts()
    fig1, ax1 = plt.subplots(figsize=(6, 6))
    ax1.pie(
        gender_counts,
        labels=gender_counts.index,
        autopct='%1.1f%%',
        startangle=140,
        colors=sns.color_palette('pastel')
    )
    ax1.set_title('Distribuci√≥n de G√©nero')
    ax1.axis('equal')
    st.pyplot(fig1)
    st.info("üìù **Conclusi√≥n:** La distribuci√≥n de g√©nero es bastante equilibrada, aunque puede observarse una ligera predominancia de alguno de los grupos seg√∫n el caso. Este equilibrio permite un an√°lisis representativo de la poblaci√≥n estudiada.")

    # üéì Distribuci√≥n de Nivel Educativo
    st.markdown("### üéì Distribuci√≥n de Nivel Educativo")
    nivel_educativo_percentages = dataset['Nivel_Educativo'].value_counts(normalize=True) * 100
    fig2, ax2 = plt.subplots(figsize=(8, 5))
    sns.barplot(
        x=nivel_educativo_percentages.index,
        y=nivel_educativo_percentages.values,
        palette='viridis',
        ax=ax2
    )
    ax2.set_title('Distribuci√≥n de Nivel Educativo')
    ax2.set_xlabel('Nivel Educativo')
    ax2.set_ylabel('Porcentaje (%)')
    plt.setp(ax2.get_xticklabels(), rotation=45, ha='right')
    for p in ax2.patches:
        percentage = f'{p.get_height():.1f}%'
        x = p.get_x() + p.get_width() / 2
        y = p.get_height()
        ax2.annotate(percentage, (x, y), ha='center', va='bottom')
    plt.tight_layout()
    st.pyplot(fig2)
    st.info("üìù **Conclusi√≥n:** Una mayor√≠a significativa de la poblaci√≥n cuenta con educaci√≥n superior. Esto puede influir en variables como el ingreso mensual o la satisfacci√≥n de vida, destacando la importancia de la formaci√≥n acad√©mica.")

    # üìà Histogramas con KDE
    st.markdown("### üìà Distribuciones de Variables Num√©ricas")
    ds_num = dataset.select_dtypes(include=['float64', 'int64'])

    for columna in ds_num.columns:
        st.write(f"Distribuci√≥n de **{columna}**")
        fig, ax = plt.subplots(figsize=(8, 4))
        sns.histplot(dataset[columna], kde=True, color='skyblue', ax=ax)
        ax.set_xlabel(columna)
        ax.set_ylabel("Frecuencia")
        ax.set_title(f"Distribuci√≥n de {columna}")
        ax.grid(True)
        plt.tight_layout()
        st.pyplot(fig)

        skewness = dataset[columna].skew()
        if skewness > 0.5:
            forma = "asim√©trica positiva (cola hacia la derecha)"
        elif skewness < -0.5:
            forma = "asim√©trica negativa (cola hacia la izquierda)"
        else:
            forma = "aproximadamente sim√©trica"
        st.info(f"üìù **Conclusi√≥n:** La distribuci√≥n de **{columna}** es {forma}.")

    # üì¶ Boxplots
    st.markdown("### üì¶ Boxplots de Variables Num√©ricas")
    for columna in ds_num.columns:
        st.write(f"Boxplot de **{columna}**")
        fig, ax = plt.subplots(figsize=(8, 4))
        sns.boxplot(x=dataset[columna], color='lightgreen', ax=ax)
        ax.set_title(f"Boxplot de {columna}")
        ax.set_xlabel(columna)
        ax.grid(True)
        plt.tight_layout()
        st.pyplot(fig)

        st.info(f"üìù **Conclusi√≥n:** El boxplot de **{columna}** permite visualizar la presencia de posibles valores at√≠picos y la dispersi√≥n de los datos.")

except FileNotFoundError:
    st.error("‚ùå No se encontr√≥ el archivo 'dataset_estadistica.csv'.")
except Exception as e:
    st.error(f"‚ö†Ô∏è Ocurri√≥ un error inesperado: {e}")
    

   # T√≠tulo de secci√≥n
st.subheader("üîç Regresi√≥n Lineal M√∫ltiple (con datos escalados)")

# Separaci√≥n de variables predictoras y objetivo
x = dataset.drop(['ID_Persona', 'Satisfaccion_Vida'], axis=1)
y = dataset['Satisfaccion_Vida']

# Codificaci√≥n de variables categ√≥ricas
x = pd.get_dummies(x, drop_first=True)

# Escalado
scaler = StandardScaler()
x_escalado = scaler.fit_transform(x)

# Divisi√≥n de datos
from sklearn.model_selection import train_test_split
x_train_escalado, x_test_escalado, y_train, y_test = train_test_split(
    x_escalado, y, test_size=0.2, random_state=42
)

# Entrenar modelo
modelo = LinearRegression()
modelo.fit(x_train_escalado, y_train)
y_pred = modelo.predict(x_test_escalado)

# Resultados
st.write("**Coeficientes de la regresi√≥n:**")
st.write(pd.Series(modelo.coef_, index=x.columns))

st.write("**Intercepto:**", modelo.intercept_)

r2 = r2_score(y_test, y_pred)
mse = mean_squared_error(y_test, y_pred)

st.success(f"üîπ R¬≤ Score (conjunto de prueba): {r2:.4f}")
st.info(f"üî∏ Mean Squared Error (MSE): {mse:.4f}")

# Gr√°fico de predicci√≥n vs real
st.markdown("### üìâ Comparaci√≥n: Predicci√≥n vs Valores Reales")
fig3, ax3 = plt.subplots(figsize=(6, 4))
ax3.scatter(y_test, y_pred, color='green', alpha=0.6)
ax3.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'k--', lw=2)
ax3.set_xlabel("Valores reales (y_test)")
ax3.set_ylabel("Predicci√≥n (y_pred)")
ax3.set_title("Regresi√≥n Lineal M√∫ltiple - y_test vs y_pred")
ax3.grid(True)
st.pyplot(fig3)

# Heatmap de correlaci√≥n
st.markdown("### üßä Matriz de Correlaci√≥n")
correlation_matrix = dataset.corr(numeric_only=True)

fig4, ax4 = plt.subplots(figsize=(8, 6))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f", ax=ax4)
ax4.set_title("Matriz de Correlaci√≥n")
st.pyplot(fig4)

# Pairplot
st.markdown("### üîó Relaciones entre Variables Num√©ricas")
try:
    import seaborn as sns
    import matplotlib.pyplot as plt

    pairplot_fig = sns.pairplot(dataset[numeric_cols + ['Satisfaccion_Vida']])
    st.pyplot(pairplot_fig.figure)
except Exception as e:
    st.warning(f"No se pudo generar el pairplot: {e}")